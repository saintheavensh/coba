import { db } from "../../db";
import { journals, journalLines, accounts } from "../../db/schema";
import { eq, and, gte, lte, desc, sql } from "drizzle-orm";
import { AuditService } from "./audit.service";

export type JournalReferenceType = "sale" | "purchase" | "expense" | "service" | "depreciation" | "commission" | "supplier_payment" | "adjustment" | "asset_purchase";

export interface JournalLineInput {
    accountId: string;
    debit: number;
    credit: number;
    description?: string;
}

export interface CreateJournalInput {
    date?: Date;
    description: string;
    referenceType?: JournalReferenceType;
    referenceId?: string;
    lines: JournalLineInput[];
    isAutoGenerated?: boolean;
    createdBy?: string;
}

export interface JournalFilters {
    startDate?: string;
    endDate?: string;
    referenceType?: JournalReferenceType;
    status?: "draft" | "posted" | "voided";
    limit?: number;
    offset?: number;
}

export class JournalService {
    /**
     * Generate a unique journal ID
     */
    private static async generateId(): Promise<string> {
        const today = new Date();
        const dateStr = today.toISOString().slice(0, 10).replace(/-/g, "");
        const prefix = `JRN-${dateStr}`;

        // Count existing journals for today
        const count = await db
            .select({ count: sql<number>`count(*)` })
            .from(journals)
            .where(sql`${journals.id} LIKE ${prefix + '%'}`);

        const num = (count[0]?.count || 0) + 1;
        return `${prefix}-${String(num).padStart(3, "0")}`;
    }

    /**
     * Create a new journal entry with validation
     */
    static async create(input: CreateJournalInput, userId?: string): Promise<string> {
        // Validate double-entry: total debits must equal total credits
        const totalDebit = input.lines.reduce((sum, line) => sum + line.debit, 0);
        const totalCredit = input.lines.reduce((sum, line) => sum + line.credit, 0);

        if (totalDebit !== totalCredit) {
            throw new Error(`Journal entry not balanced: Debit ${totalDebit} != Credit ${totalCredit}`);
        }

        if (input.lines.length < 2) {
            throw new Error("Journal entry must have at least 2 lines");
        }

        const journalId = await this.generateId();

        // Insert journal header
        await db.insert(journals).values({
            id: journalId,
            date: input.date || new Date(),
            description: input.description,
            referenceType: input.referenceType,
            referenceId: input.referenceId,
            status: "posted",
            totalDebit,
            totalCredit,
            isAutoGenerated: input.isAutoGenerated ?? true,
            createdBy: userId || input.createdBy,
            postedBy: userId || input.createdBy,
            postedAt: new Date(),
        });

        // Insert journal lines
        for (const line of input.lines) {
            await db.insert(journalLines).values({
                journalId,
                accountId: line.accountId,
                debit: line.debit,
                credit: line.credit,
                description: line.description,
            });

            // Update account balance
            await this.updateAccountBalance(line.accountId, line.debit, line.credit);
        }

        // Audit log
        await AuditService.log({
            userId,
            action: "CREATE",
            entityType: "journal",
            entityId: journalId,
            tableName: "journals",
            newValues: { description: input.description, totalDebit, totalCredit, referenceType: input.referenceType },
        });

        return journalId;
    }

    /**
     * Update account balance based on debit/credit
     */
    private static async updateAccountBalance(
        accountId: string,
        debit: number,
        credit: number
    ): Promise<void> {
        const [account] = await db
            .select()
            .from(accounts)
            .where(eq(accounts.id, accountId));

        if (!account) {
            throw new Error(`Account ${accountId} not found`);
        }

        // Get account type to determine normal balance
        // For ASSET and EXPENSE: debit increases, credit decreases
        // For LIABILITY, EQUITY, REVENUE: credit increases, debit decreases
        const isDebitNormal = account.typeId === "ASSET" || account.typeId === "EXPENSE";
        const netChange = isDebitNormal ? (debit - credit) : (credit - debit);

        await db
            .update(accounts)
            .set({
                balance: sql`${accounts.balance} + ${netChange}`,
                updatedAt: new Date(),
            })
            .where(eq(accounts.id, accountId));
    }

    /**
     * Void a journal entry (reverse its effects)
     */
    static async void(journalId: string, reason: string, userId: string): Promise<void> {
        const [journal] = await db
            .select()
            .from(journals)
            .where(eq(journals.id, journalId));

        if (!journal) {
            throw new Error(`Journal ${journalId} not found`);
        }

        if (journal.status === "voided") {
            throw new Error("Journal is already voided");
        }

        // Get journal lines and reverse the account balances
        const lines = await db
            .select()
            .from(journalLines)
            .where(eq(journalLines.journalId, journalId));

        for (const line of lines) {
            // Reverse: swap debit and credit
            await this.updateAccountBalance(line.accountId, line.credit, line.debit);
        }

        // Update journal status
        await db
            .update(journals)
            .set({
                status: "voided",
                voidedBy: userId,
                voidedAt: new Date(),
                voidReason: reason,
            })
            .where(eq(journals.id, journalId));

        // Audit log
        await AuditService.log({
            userId,
            action: "VOID",
            entityType: "journal",
            entityId: journalId,
            tableName: "journals",
            oldValues: { status: journal.status },
            newValues: { status: "voided", voidReason: reason },
            reason,
        });
    }

    /**
     * Delete a journal and reverse its impact on account balances
     */
    static async delete(journalId: string, userId?: string): Promise<void> {
        const journal = await this.getById(journalId);
        if (!journal) {
            throw new Error(`Journal ${journalId} not found`);
        }

        // Only reverse balance if it was posted
        if (journal.status === "posted") {
            for (const line of journal.lines) {
                // Reverse: swap debit and credit
                await this.updateAccountBalance(line.accountId, line.credit, line.debit);
            }
        }

        // Delete journal (lines will cascade)
        await db.delete(journals).where(eq(journals.id, journalId));

        // Audit log
        await AuditService.log({
            userId,
            action: "DELETE",
            entityType: "journal",
            entityId: journalId,
            tableName: "journals",
            oldValues: journal,
        });
    }

    /**
     * Delete journals by reference
     */
    static async deleteByReference(referenceType: string, referenceId: string, userId?: string): Promise<void> {
        const matchingJournals = await db
            .select({ id: journals.id })
            .from(journals)
            .where(
                and(
                    eq(journals.referenceType, referenceType),
                    eq(journals.referenceId, referenceId)
                )
            );

        for (const j of matchingJournals) {
            await this.delete(j.id, userId);
        }
    }

    /**
     * Get journals with filters
     */
    static async getAll(filters: JournalFilters = {}) {
        const { startDate, endDate, referenceType, status, limit = 50, offset = 0 } = filters;

        const conditions = [];

        if (startDate) {
            conditions.push(gte(journals.date, new Date(startDate)));
        }
        if (endDate) {
            conditions.push(lte(journals.date, new Date(endDate)));
        }
        if (referenceType) {
            conditions.push(eq(journals.referenceType, referenceType));
        }
        if (status) {
            conditions.push(eq(journals.status, status));
        }

        const query = db
            .select()
            .from(journals)
            .orderBy(desc(journals.date))
            .limit(limit)
            .offset(offset);

        if (conditions.length > 0) {
            return query.where(and(...conditions));
        }

        return query;
    }

    /**
     * Get a journal with its lines
     */
    static async getById(journalId: string) {
        const [journal] = await db
            .select()
            .from(journals)
            .where(eq(journals.id, journalId));

        if (!journal) {
            return null;
        }

        const lines = await db
            .select({
                id: journalLines.id,
                accountId: journalLines.accountId,
                accountName: accounts.name,
                accountCode: accounts.code,
                debit: journalLines.debit,
                credit: journalLines.credit,
                description: journalLines.description,
            })
            .from(journalLines)
            .leftJoin(accounts, eq(journalLines.accountId, accounts.id))
            .where(eq(journalLines.journalId, journalId));

        return { ...journal, lines };
    }

    /**
     * Auto-create journal for a sale
     */
    static async createSaleJournal(
        saleId: string,
        amount: number,
        paymentMethod: string,
        hppAmount: number,
        userId?: string
    ): Promise<string> {
        const cashAccountId = paymentMethod === "transfer" ? "1-1002" : "1-1001"; // BCA or Kas Toko

        return this.create({
            description: `Penjualan ${saleId}`,
            referenceType: "sale",
            referenceId: saleId,
            lines: [
                { accountId: cashAccountId, debit: amount, credit: 0, description: "Penerimaan kas" },
                { accountId: "4-1000", debit: 0, credit: amount, description: "Pendapatan penjualan" },
                { accountId: "5-1001", debit: hppAmount, credit: 0, description: "HPP barang terjual" },
                { accountId: "1-3000", debit: 0, credit: hppAmount, description: "Pengurangan persediaan" },
            ],
        }, userId);
    }

    /**
     * Auto-create journal for a service pickup (diambil)
     */
    static async createServiceJournal(
        serviceNo: string,
        amount: number,
        paymentMethod: string,
        partsHpp?: number,
        userId?: string
    ): Promise<string> {
        const cashAccountId = paymentMethod === "transfer" ? "1-1002" : "1-1001";

        const lines: JournalLineInput[] = [
            { accountId: cashAccountId, debit: amount, credit: 0, description: "Penerimaan kas" },
            { accountId: "4-2000", debit: 0, credit: amount, description: "Pendapatan service" },
        ];

        // If parts were used from inventory
        if (partsHpp && partsHpp > 0) {
            lines.push(
                { accountId: "5-1002", debit: partsHpp, credit: 0, description: "HPP sparepart" },
                { accountId: "1-3000", debit: 0, credit: partsHpp, description: "Pengurangan persediaan" }
            );
        }

        return this.create({
            description: `Service ${serviceNo}`,
            referenceType: "service",
            referenceId: serviceNo,
            lines,
        }, userId);
    }

    /**
     * Auto-create journal for an expense
     */
    static async createExpenseJournal(
        expenseId: string,
        amount: number,
        category: string,
        paymentMethod: string,
        userId?: string
    ): Promise<string> {
        const cashAccountId = paymentMethod === "transfer" ? "1-1002" : "1-1001";

        // Map expense category to account
        const expenseAccountMap: Record<string, string> = {
            "Listrik": "5-2001",
            "Internet": "5-2002",
            "Sewa": "5-2003",
            "Gaji": "5-2004",
            "default": "5-2000",
        };

        const expenseAccountId = expenseAccountMap[category] || expenseAccountMap.default;

        return this.create({
            description: `Beban: ${category}`,
            referenceType: "expense",
            referenceId: expenseId,
            lines: [
                { accountId: expenseAccountId, debit: amount, credit: 0, description: category },
                { accountId: cashAccountId, debit: 0, credit: amount, description: "Pengeluaran kas" },
            ],
        }, userId);
    }

    /**
     * Auto-create journal for a purchase (on credit)
     */
    static async createPurchaseJournal(
        purchaseId: string,
        amount: number,
        isPaid: boolean,
        paymentMethod?: string,
        userId?: string
    ): Promise<string> {
        const lines: JournalLineInput[] = [
            { accountId: "1-3000", debit: amount, credit: 0, description: "Penambahan persediaan" },
        ];

        if (isPaid) {
            const cashAccountId = paymentMethod === "transfer" ? "1-1002" : "1-1001";
            lines.push({ accountId: cashAccountId, debit: 0, credit: amount, description: "Pembayaran kas" });
        } else {
            lines.push({ accountId: "2-1000", debit: 0, credit: amount, description: "Hutang usaha" });
        }

        return this.create({
            description: `Pembelian ${purchaseId}`,
            referenceType: "purchase",
            referenceId: purchaseId,
            lines,
        }, userId);
    }
}
